// Generated by CoffeeScript 1.6.3
(function() {
  var BACKSPACE, BaseClass, CASE_SENSITIVE_ATTRIBUTES, DELETE, Mark, MarkingSurface, NAMESPACES, POINTER_EVENTS, SVG, TAB, Tool, ToolControls, defs, elements, filters, name, removeFrom, toggleClass, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  removeFrom = function(item, array) {
    var i, thing, _i;
    for (i = _i = array.length - 1; _i >= 0; i = _i += -1) {
      thing = array[i];
      if (thing === item) {
        array.splice(i, 1);
      }
    }
    return null;
  };

  toggleClass = function(element, className, condition) {
    var classList, contained;
    classList = element.className.split(/\s+/);
    contained = __indexOf.call(classList, className) >= 0;
    if (condition == null) {
      condition = !contained;
    }
    condition = !!condition;
    if (!contained && condition === true) {
      classList.push(className);
    }
    if (contained && condition === false) {
      removeFrom(className, classList);
    }
    element.className = classList.join(' ');
    return null;
  };

  BaseClass = (function() {
    BaseClass.prototype._events = null;

    function BaseClass(params) {
      var property, value;
      if (params == null) {
        params = {};
      }
      for (property in params) {
        if (!__hasProp.call(params, property)) continue;
        value = params[property];
        if (property in this) {
          this[property] = value;
        }
      }
      this._events = {};
    }

    BaseClass.prototype.on = function(eventName, handler) {
      var _base;
      if ((_base = this._events)[eventName] == null) {
        _base[eventName] = [];
      }
      this._events[eventName].push(handler);
      return null;
    };

    BaseClass.prototype.trigger = function(eventName, args) {
      var handler, _i, _len, _ref;
      _ref = this._events[eventName] || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        handler.apply(this, args || []);
      }
      return null;
    };

    BaseClass.prototype.off = function(eventName, handler) {
      var handlerList, property;
      if (eventName != null) {
        handlerList = this._events[eventName] || [];
        if (handler != null) {
          removeFrom(handler, handlerList);
        } else {
          handlerList.splice(0);
        }
      } else {
        for (property in this._events) {
          delete this._events[property];
        }
      }
      return null;
    };

    BaseClass.prototype.destroy = function() {
      this.trigger('destroy');
      this.off();
      return null;
    };

    return BaseClass;

  })();

  NAMESPACES = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink'
  };

  CASE_SENSITIVE_ATTRIBUTES = ['viewBox'];

  filters = {
    shadow: [
      {
        element: 'feOffset',
        attributes: {
          "in": 'SourceAlpha',
          dx: 0.5,
          dy: 1.5,
          result: 'offOut'
        }
      }, {
        element: 'feBlend',
        attributes: {
          "in": 'SourceGraphic',
          in2: 'offOut'
        }
      }
    ]
  };

  SVG = (function() {
    SVG.prototype.el = null;

    function SVG(tagName, attributes) {
      var classes, namespace, _i, _ref, _ref1, _ref2;
      if (typeof tagName !== 'string') {
        _ref = ['svg', tagName], tagName = _ref[0], attributes = _ref[1];
      }
      _ref1 = tagName.split('.'), tagName = _ref1[0], classes = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
      classes = classes.join(' ');
      _ref2 = tagName.split(':'), namespace = 2 <= _ref2.length ? __slice.call(_ref2, 0, _i = _ref2.length - 1) : (_i = 0, []), tagName = _ref2[_i++];
      namespace = namespace.join('');
      namespace || (namespace = 'svg');
      this.el = document.createElementNS(NAMESPACES[namespace] || null, tagName);
      if (classes) {
        this.attr('class', classes);
      }
      this.attr(attributes);
    }

    SVG.prototype.attr = function(attribute, value) {
      var attributes, namespace, _i, _ref;
      if (typeof attribute === 'string') {
        if (__indexOf.call(CASE_SENSITIVE_ATTRIBUTES, attribute) < 0) {
          attribute = (attribute.replace(/([A-Z])/g, '-$1')).toLowerCase();
        }
        _ref = attribute.split(':'), namespace = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), attribute = _ref[_i++];
        namespace = namespace.join('');
        this.el.setAttributeNS(NAMESPACES[namespace] || null, attribute, value);
      } else {
        attributes = attribute;
        for (attribute in attributes) {
          value = attributes[attribute];
          this.attr(attribute, value);
        }
      }
      return null;
    };

    SVG.prototype.filter = function(name) {
      return this.attr('filter', name != null ? "url(#marking-surface-filter-" + name + ")" : '');
    };

    SVG.prototype.addShape = function(tagName, attributes) {
      var shape;
      shape = new this.constructor(tagName, attributes);
      this.el.appendChild(shape.el);
      return shape;
    };

    SVG.prototype.toFront = function() {
      this.el.parentNode.appendChild(this.el);
      return null;
    };

    SVG.prototype.remove = function() {
      this.el.parentNode.removeChild(this.el);
      return null;
    };

    return SVG;

  })();

  SVG.filtersContainer = new SVG({
    id: 'marking-surface-filters-container',
    width: 0,
    height: 0,
    style: 'bottom: 0; position: absolute; right: 0;'
  });

  defs = SVG.filtersContainer.addShape('defs');

  SVG.registerFilter = function(name, elements) {
    var attributes, element, filter, _i, _len, _ref;
    filters[name] = elements;
    filter = defs.addShape('filter', {
      id: "marking-surface-filter-" + name
    });
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      _ref = elements[_i], element = _ref.element, attributes = _ref.attributes;
      filter.addShape(element, attributes);
    }
    return null;
  };

  for (name in filters) {
    elements = filters[name];
    SVG.registerFilter(name, elements);
  }

  document.body.appendChild(SVG.filtersContainer.el);

  Mark = (function(_super) {
    __extends(Mark, _super);

    function Mark() {
      _ref = Mark.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Mark.prototype.set = function(property, value, _arg) {
      var fromMany, properties, setValue, setter;
      fromMany = (_arg != null ? _arg : {}).fromMany;
      if (typeof property === 'string') {
        setter = this["set " + property];
        setValue = setter != null ? setter.call(this, value) : value;
        this[property] = setValue;
        this.trigger("change-property", [setValue]);
      } else {
        properties = property;
        for (property in properties) {
          value = properties[property];
          this.set(property, value, {
            fromMany: true
          });
        }
      }
      if (!fromMany) {
        this.trigger('change', [property, value]);
      }
      return null;
    };

    Mark.prototype.toJSON = function() {
      var property, result, value;
      result = {};
      for (property in this) {
        value = this[property];
        if ((property.charAt(0)) === '_') {
          continue;
        }
        if (typeof value === 'function') {
          continue;
        }
        result[property] = this[property];
      }
      return result;
    };

    return Mark;

  })(BaseClass);

  ToolControls = (function(_super) {
    __extends(ToolControls, _super);

    ToolControls.prototype.tool = null;

    ToolControls.prototype.tagName = 'div';

    ToolControls.prototype.className = 'marking-tool-controls';

    ToolControls.prototype.deleteButtonName = 'delete-marking-tool';

    ToolControls.prototype.el = null;

    ToolControls.prototype.deleteButton = null;

    ToolControls.prototype.template = "<button name=\"" + ToolControls.prototype.deleteButtonName + "\">&times;</button>";

    function ToolControls() {
      this.onToolDestroy = __bind(this.onToolDestroy, this);
      this.onToolDeselect = __bind(this.onToolDeselect, this);
      this.onMarkChange = __bind(this.onMarkChange, this);
      this.onToolSelect = __bind(this.onToolSelect, this);
      this.onClickDelete = __bind(this.onClickDelete, this);
      this.onMouseDown = __bind(this.onMouseDown, this);
      this.onToolInitialRelease = __bind(this.onToolInitialRelease, this);
      var _ref1;
      ToolControls.__super__.constructor.apply(this, arguments);
      this.el = document.createElement(this.tagName);
      this.el.className = this.className;
      this.el.style.position = 'absolute';
      this.el.innerHTML = this.template;
      this.el.addEventListener('mousedown', this.onMouseDown, false);
      this.deleteButton = this.el.querySelector("button[name='" + this.deleteButtonName + "']");
      if ((_ref1 = this.deleteButton) != null) {
        _ref1.addEventListener('click', this.onClickDelete, false);
      }
      this.tool.on('initial-release', this.onToolInitialRelease);
      this.tool.on('select', this.onToolSelect);
      this.tool.mark.on('change', this.onMarkChange);
      this.tool.on('deselect', this.onToolDeselect);
      this.tool.on('destroy', this.onToolDestroy);
      this.tool.surface.el.appendChild(this.el);
    }

    ToolControls.prototype.onToolInitialRelease = function() {
      toggleClass(this.el, 'tool-is-complete', this.tool.isComplete());
      return null;
    };

    ToolControls.prototype.onMouseDown = function() {
      if (this.tool.surface.disabled) {
        return;
      }
      this.tool.select();
      return null;
    };

    ToolControls.prototype.onClickDelete = function(e) {
      if (this.tool.surface.disabled) {
        return;
      }
      e.preventDefault();
      this.tool.mark.destroy();
      return null;
    };

    ToolControls.prototype.onToolSelect = function() {
      toggleClass(this.el, 'tool-selected', true);
      return null;
    };

    ToolControls.prototype.onMarkChange = function() {
      this.render.apply(this, arguments);
      return null;
    };

    ToolControls.prototype.onToolDeselect = function() {
      toggleClass(this.el, 'tool-selected', false);
      return null;
    };

    ToolControls.prototype.onToolDestroy = function() {
      this.destroy();
      return null;
    };

    ToolControls.prototype.destroy = function() {
      this.el.removeEventListener('mousedown', this.onMouseDown, false);
      this.deleteButton.removeEventListener('click', this.onClickDelete, false);
      this.el.parentNode.removeChild(this.el);
      ToolControls.__super__.destroy.apply(this, arguments);
      return null;
    };

    ToolControls.prototype.moveTo = function(x, y, dontTryAndBeClever) {
      var bottom, height, left, outOfBounds, panX, panY, right, top, width, zoomBy, _ref1, _ref2, _ref3;
      if (dontTryAndBeClever == null) {
        dontTryAndBeClever = false;
      }
      _ref1 = this.tool.surface, zoomBy = _ref1.zoomBy, panX = _ref1.panX, panY = _ref1.panY, width = _ref1.width, height = _ref1.height;
      panX *= width - (width / zoomBy);
      panY *= height - (height / zoomBy);
      _ref2 = dontTryAndBeClever || x < width / 2 ? [(x * zoomBy) - (panX * zoomBy), null] : [null, width - ((x * zoomBy) - (panX * zoomBy))], left = _ref2[0], right = _ref2[1];
      _ref3 = dontTryAndBeClever || y < height / 2 ? [(y * zoomBy) - (panY * zoomBy), null] : [null, height - ((y * zoomBy) - (panY * zoomBy))], top = _ref3[0], bottom = _ref3[1];
      outOfBounds = left < 0 || right < 0 || top < 0 || bottom < 0;
      outOfBounds || (outOfBounds = left > width || right > width || top > height || bottom > height);
      this.el.style.left = left != null ? "" + left + "px" : '';
      this.el.style.right = right != null ? "" + right + "px" : '';
      this.el.style.top = top != null ? "" + top + "px" : '';
      this.el.style.bottom = bottom != null ? "" + bottom + "px" : '';
      this.el.style.display = outOfBounds ? 'none' : '';
      toggleClass(this.el, 'opens-right', left != null);
      toggleClass(this.el, 'opens-left', right != null);
      toggleClass(this.el, 'opens-down', top != null);
      toggleClass(this.el, 'opens-up', bottom != null);
      return null;
    };

    ToolControls.prototype.render = function() {};

    return ToolControls;

  })(BaseClass);

  POINTER_EVENTS = ['mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup', 'touchstart', 'touchmove', 'touchend'];

  Tool = (function(_super) {
    __extends(Tool, _super);

    Tool.Mark = Mark;

    Tool.Controls = ToolControls;

    Tool.prototype.cursors = null;

    Tool.prototype.deselectedOpacity = 0.5;

    Tool.prototype.renderFps = 30;

    Tool.prototype.surface = null;

    Tool.prototype.mark = null;

    Tool.prototype.controls = null;

    Tool.prototype.root = null;

    Tool.prototype.group = null;

    Tool.prototype.drags = 0;

    Tool.prototype.renderTimeout = NaN;

    function Tool() {
      this.destroy = __bind(this.destroy, this);
      this.onMarkDestory = __bind(this.onMarkDestory, this);
      this.onMarkChange = __bind(this.onMarkChange, this);
      this.handleEvents = __bind(this.handleEvents, this);
      var eventName, _i, _len;
      Tool.__super__.constructor.apply(this, arguments);
      if (this.mark == null) {
        this.mark = new this.constructor.Mark;
      }
      this.mark.on('change', this.onMarkChange);
      this.mark.on('destroy', this.onMarkDestory);
      this.controls = new this.constructor.Controls({
        tool: this
      });
      this.root = this.surface.addShape('g.marking-tool-root');
      this.group = this.root.addShape('g.marking-tool');
      this.group.attr({
        fill: 'transparent',
        stroke: 'transparent',
        strokeWidth: 0
      });
      for (_i = 0, _len = POINTER_EVENTS.length; _i < _len; _i++) {
        eventName = POINTER_EVENTS[_i];
        this.group.el.addEventListener(eventName, this.handleEvents, false);
      }
      this.initialize.apply(this, arguments);
    }

    Tool.prototype.addShape = function() {
      var _ref1;
      return (_ref1 = this.group).addShape.apply(_ref1, arguments);
    };

    Tool.prototype.onInitialClick = function(e) {
      this.trigger('initial-click', [e]);
      return this.onFirstClick(e);
    };

    Tool.prototype.onInitialDrag = function(e) {
      this.trigger('initial-drag', [e]);
      return this.onFirstDrag(e);
    };

    Tool.prototype.onInitialRelease = function(e) {
      this.drags += 1;
      this.trigger('initial-release', [e]);
      return this.onFirstRelease(e);
    };

    Tool.prototype.isComplete = function() {
      return this.drags === 1;
    };

    Tool.prototype.handleEvents = function(e) {
      var dragEvent, endEvent, eventName, match, onEnd, onNamedEnd, property, target, value, valueItem, _i, _len, _ref1, _ref2, _ref3,
        _this = this;
      if (this.surface.disabled) {
        return;
      }
      eventName = e.type;
      ({
        name: '*'
      });
      target = e.target || e.srcElement;
      for (property in this) {
        value = this[property];
        match = (value != null ? value.el : void 0) === target;
        if (value instanceof Array) {
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            valueItem = value[_i];
            match || (match = (valueItem != null ? valueItem.el : void 0) === target);
          }
        }
        if (match) {
          name = property;
          target = value;
        }
      }
      if ((_ref1 = this["on " + eventName]) != null) {
        _ref1.call(this, e);
      }
      if ((_ref2 = this["on " + eventName + " " + name]) != null) {
        _ref2.call(this, e);
      }
      switch (eventName) {
        case 'mouseover':
          return this.surface.el.style.cursor = (_ref3 = this.cursors) != null ? _ref3[name] : void 0;
        case 'mouseout':
          return this.surface.el.style.cursor = this.surface.cursor;
        case 'mousedown':
        case 'touchstart':
          e.preventDefault();
          this.select();
          dragEvent = eventName === 'mousedown' ? 'mousemove' : 'touchmove';
          endEvent = eventName === 'mousedown' ? 'mouseup' : 'touchend';
          if ('on drag' in this) {
            this["on drag"](e);
            document.addEventListener(dragEvent, this['on drag'], false);
            onEnd = function() {
              document.removeEventListener(dragEvent, _this['on drag'], false);
              return document.removeEventListener(endEvent, onEnd, false);
            };
            document.addEventListener(endEvent, onEnd, false);
          }
          if (("on drag " + name) in this) {
            this["on drag " + name](e);
            document.addEventListener(dragEvent, this["on drag " + name], false);
            onNamedEnd = function() {
              document.removeEventListener(dragEvent, _this["on drag " + name], false);
              return document.removeEventListener(endEvent, onNamedEnd, false);
            };
            return document.addEventListener(endEvent, onNamedEnd, false);
          }
      }
    };

    Tool.prototype.onMarkChange = function() {
      var _this = this;
      if (!isNaN(this.renderTimeout)) {
        return;
      }
      this.render.apply(this, arguments);
      return this.renderTimeout = setTimeout((function() {
        _this.render(arguments);
        return _this.renderTimeout = NaN;
      }), 1000 / this.renderFps);
    };

    Tool.prototype.onMarkDestory = function() {
      this.destroy.apply(this, arguments);
      return null;
    };

    Tool.prototype.select = function() {
      this.group.attr('opacity', 1);
      this.group.toFront();
      this.trigger('select', arguments);
      return null;
    };

    Tool.prototype.deselect = function() {
      this.group.attr('opacity', this.deselectedOpacity);
      this.trigger('deselect', arguments);
      return null;
    };

    Tool.prototype.destroy = function() {
      var eventName, _i, _len;
      for (_i = 0, _len = POINTER_EVENTS.length; _i < _len; _i++) {
        eventName = POINTER_EVENTS[_i];
        this.group.el.removeEventListener(eventName, this.handleEvents, false);
      }
      this.group.remove();
      Tool.__super__.destroy.apply(this, arguments);
      return null;
    };

    Tool.prototype.pointerOffset = function() {
      var _ref1;
      return (_ref1 = this.surface).pointerOffset.apply(_ref1, arguments);
    };

    Tool.prototype.initialize = function() {};

    Tool.prototype.onFirstClick = function(e) {};

    Tool.prototype.onFirstDrag = function(e) {};

    Tool.prototype.onFirstRelease = function(e) {};

    Tool.prototype.render = function() {};

    return Tool;

  })(BaseClass);

  BACKSPACE = 8;

  DELETE = 46;

  TAB = 9;

  MarkingSurface = (function(_super) {
    __extends(MarkingSurface, _super);

    MarkingSurface.prototype.tool = Tool;

    MarkingSurface.prototype.width = NaN;

    MarkingSurface.prototype.height = NaN;

    MarkingSurface.prototype.el = null;

    MarkingSurface.prototype.tagName = 'div';

    MarkingSurface.prototype.className = 'marking-surface';

    MarkingSurface.prototype.tabIndex = 0;

    MarkingSurface.prototype.cursor = 'crosshair';

    MarkingSurface.prototype.svg = null;

    MarkingSurface.prototype.zoomBy = 1;

    MarkingSurface.prototype.zoomSnapTolerance = 0.05;

    MarkingSurface.prototype.panX = 0.5;

    MarkingSurface.prototype.panY = 0.5;

    MarkingSurface.prototype.tools = null;

    MarkingSurface.prototype.selection = null;

    MarkingSurface.prototype.marks = null;

    MarkingSurface.prototype.disabled = false;

    MarkingSurface.prototype.offsetAtLastMousedown = null;

    function MarkingSurface() {
      this.onKeyDown = __bind(this.onKeyDown, this);
      this.onTouchStart = __bind(this.onTouchStart, this);
      this.onRelease = __bind(this.onRelease, this);
      this.onDrag = __bind(this.onDrag, this);
      this.onMouseDown = __bind(this.onMouseDown, this);
      this.onTouchMove = __bind(this.onTouchMove, this);
      this.onMouseMove = __bind(this.onMouseMove, this);
      MarkingSurface.__super__.constructor.apply(this, arguments);
      if (typeof this.el === 'string') {
        this.el = document.querySelectorAll(this.el);
      }
      if (this.el == null) {
        this.el = document.createElement(this.tagName);
      }
      this.el.className = this.className;
      this.el.setAttribute('tabindex', this.tabIndex);
      this.el.addEventListener('mousemove', this.onMouseMove, false);
      this.el.addEventListener('touchmove', this.onTouchMove, false);
      this.el.addEventListener('mousedown', this.onMouseDown, false);
      this.el.addEventListener('touchstart', this.onTouchStart, false);
      this.el.addEventListener('keydown', this.onKeyDown, false);
      if (this.el.parentNode != null) {
        this.width || (this.width = this.el.clientWidth);
        this.height || (this.height = this.el.clientHeight);
      }
      if (this.svg == null) {
        this.svg = new SVG({
          width: this.width,
          height: this.height
        });
      }
      this.el.style.cursor = this.cursor;
      this.svg.el.style.display = 'block';
      this.svg.el.style.overflow = 'hidden';
      this.el.appendChild(this.svg.el);
      if (this.marks == null) {
        this.marks = [];
      }
      if (this.tools == null) {
        this.tools = [];
      }
      if (this.disabled) {
        disable();
      }
    }

    MarkingSurface.prototype.resize = function(width, height) {
      this.width = width != null ? width : this.width;
      this.height = height != null ? height : this.height;
      this.svg.attr({
        width: this.width,
        height: this.height
      });
      return null;
    };

    MarkingSurface.prototype.zoom = function(zoomBy) {
      this.zoomBy = zoomBy != null ? zoomBy : 1;
      if (this.zoomBy < 1 + this.zoomSnapTolerance) {
        this.zoomBy = 1;
        this.panX = this.constructor.prototype.panX;
        this.panY = this.constructor.prototype.panY;
      }
      this.pan();
      return null;
    };

    MarkingSurface.prototype.pan = function(panX, panY) {
      var height, minX, minY, tool, width, _i, _len, _ref1;
      this.panX = panX != null ? panX : this.panX;
      this.panY = panY != null ? panY : this.panY;
      minX = (this.width - (this.width / this.zoomBy)) * this.panX;
      minY = (this.height - (this.height / this.zoomBy)) * this.panY;
      width = this.width / this.zoomBy;
      height = this.height / this.zoomBy;
      this.svg.attr('viewBox', "" + minX + " " + minY + " " + width + " " + height);
      _ref1 = this.tools;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tool = _ref1[_i];
        tool.render();
      }
      return null;
    };

    MarkingSurface.prototype.onMouseMove = function(e) {
      var x, y, _ref1;
      if (this.zoomBy === 1) {
        return;
      }
      _ref1 = this.pointerOffset(e), x = _ref1.x, y = _ref1.y;
      this.pan(x / this.width, y / this.height);
      return null;
    };

    MarkingSurface.prototype.onTouchMove = function(e) {
      this.onMouseMove(e);
      return null;
    };

    MarkingSurface.prototype.onMouseDown = function(e) {
      var dragEvent, mark, releaseEvent, tool, _ref1,
        _this = this;
      if (this.disabled) {
        return;
      }
      if (e.defaultPrevented) {
        return;
      }
      if (_ref1 = e.target, __indexOf.call(this.el.querySelectorAll("." + ToolControls.prototype.className + ", ." + ToolControls.prototype.className + " *"), _ref1) >= 0) {
        return;
      }
      e.preventDefault();
      this.el.focus();
      this.offsetAtLastMousedown = this.elOffset();
      if ((this.selection == null) || this.selection.isComplete()) {
        if (this.tool != null) {
          tool = new this.tool({
            surface: this
          });
          mark = tool.mark;
          tool.on('select', function() {
            var _ref2;
            if (_this.selection === tool) {
              return;
            }
            if ((_ref2 = _this.selection) != null) {
              _ref2.deselect();
            }
            removeFrom(tool, _this.tools);
            _this.tools.push(tool);
            _this.selection = tool;
            return _this.trigger('select-tool', [_this.selection]);
          });
          tool.on('deselect', function() {
            return _this.selection = null;
          });
          tool.on('destroy', function() {
            var _ref2;
            removeFrom(tool, _this.tools);
            _this.trigger('destroy-tool', [tool]);
            if (tool === _this.selection) {
              return (_ref2 = _this.tools[_this.tools.length - 1]) != null ? _ref2.select() : void 0;
            }
          });
          this.tools.push(tool);
          this.trigger('create-tool', [tool]);
          mark.on('change', function() {
            return _this.trigger('change', [mark]);
          });
          mark.on('destroy', function() {
            removeFrom(mark, _this.marks);
            _this.trigger('destroy-mark', [mark]);
            return _this.trigger('change', [mark]);
          });
          this.marks.push(mark);
          this.trigger('create-mark', [mark]);
          this.trigger('change', []);
        }
      } else {
        tool = this.selection;
      }
      if (tool != null) {
        tool.select();
        tool.onInitialClick(e);
      }
      dragEvent = e.type === 'mousedown' ? 'mousemove' : 'touchmove';
      releaseEvent = e.type === 'mousedown' ? 'mouseup' : 'touchend';
      document.addEventListener(dragEvent, this.onDrag, false);
      document.addEventListener(releaseEvent, this.onRelease, false);
      return null;
    };

    MarkingSurface.prototype.onDrag = function(e) {
      var _ref1;
      e.preventDefault();
      if ((_ref1 = this.selection) != null) {
        _ref1.onInitialDrag.apply(_ref1, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.onRelease = function(e) {
      var dragEvent, _ref1;
      e.preventDefault();
      dragEvent = e.type === 'mouseup' ? 'mousemove' : 'touchmove';
      document.removeEventListener(dragEvent, this.onDrag, false);
      document.removeEventListener(e.type, this.onRelease, false);
      if ((_ref1 = this.selection) != null) {
        _ref1.onInitialRelease.apply(_ref1, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.onTouchStart = function(e) {
      if (e.touches.length === 1) {
        this.onMouseDown(e);
      }
      return null;
    };

    MarkingSurface.prototype.onKeyDown = function(e) {
      var current, next, _ref1, _ref2, _ref3;
      if (this.disabled) {
        return;
      }
      if (e.altKey || e.ctrlKey) {
        return;
      }
      if ((_ref1 = e.which) !== BACKSPACE && _ref1 !== DELETE && _ref1 !== TAB) {
        return;
      }
      if (document.activeElement !== this.el) {
        return;
      }
      switch (e.which) {
        case BACKSPACE:
        case DELETE:
          e.preventDefault();
          return (_ref2 = this.selection) != null ? _ref2.mark.destroy() : void 0;
        case TAB:
          e.preventDefault();
          if (e.shiftKey) {
            return (_ref3 = this.tools[0]) != null ? _ref3.select() : void 0;
          } else {
            e.preventDefault();
            current = this.selection;
            next = this.tools[this.tools.length - 2];
            if (next != null) {
              next.select();
              removeFrom(current, this.tools);
              return this.tools.unshift(current);
            }
          }
      }
    };

    MarkingSurface.prototype.getValue = function() {
      return JSON.stringify(this.marks);
    };

    MarkingSurface.prototype.addShape = function() {
      var _ref1;
      return (_ref1 = this.svg).addShape.apply(_ref1, arguments);
    };

    MarkingSurface.prototype.disable = function(e) {
      var _ref1;
      if (this.disabled) {
        return;
      }
      this.disabled = true;
      this.el.setAttribute('disabled', 'disabled');
      if ((_ref1 = this.selection) != null) {
        _ref1.deselect();
      }
      return null;
    };

    MarkingSurface.prototype.enable = function(e) {
      if (!this.disabled) {
        return;
      }
      this.disabled = false;
      this.el.removeAttribute('disabled');
      return null;
    };

    MarkingSurface.prototype.destroy = function() {
      var mark, _i, _len, _ref1;
      _ref1 = this.marks;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        mark = _ref1[_i];
        mark.destroy();
      }
      this.el.removeEventListener('mousedown', this.onMouseDown, false);
      this.el.removeEventListener('mousemove', this.onMouseMove, false);
      this.el.removeEventListener('touchstart', this.onTouchStart, false);
      this.el.removeEventListener('touchmove', this.onTouchMove, false);
      this.el.removeEventListener('keydown', this.onKeyDown, false);
      MarkingSurface.__super__.destroy.apply(this, arguments);
      return null;
    };

    MarkingSurface.prototype.elOffset = function() {
      var currentElement, left, top;
      left = 0;
      top = 0;
      currentElement = this.el;
      while (currentElement != null) {
        if (!isNaN(currentElement.offsetLeft)) {
          left += currentElement.offsetLeft;
        }
        if (!isNaN(currentElement.offsetTop)) {
          top += currentElement.offsetTop;
        }
        currentElement = currentElement.offsetParent;
      }
      left += parseFloat(getComputedStyle(document.body.parentNode).marginLeft);
      top += parseFloat(getComputedStyle(document.body.parentNode).marginTop);
      return {
        left: left,
        top: top
      };
    };

    MarkingSurface.prototype.pointerOffset = function(e) {
      var left, originalEvent, top, x, y, _ref1;
      if ('originalEvent' in e) {
        originalEvent = e.originalEvent;
      }
      if ((originalEvent != null) && 'touches' in originalEvent) {
        e = originalEvent.touches[0];
      }
      _ref1 = this.offsetAtLastMousedown || this.elOffset(), left = _ref1.left, top = _ref1.top;
      x = e.pageX - left;
      y = e.pageY - top;
      return {
        x: x,
        y: y
      };
    };

    return MarkingSurface;

  })(BaseClass);

  MarkingSurface.BaseClass = BaseClass;

  MarkingSurface.SVG = SVG;

  MarkingSurface.Mark = Mark;

  MarkingSurface.ToolControls = ToolControls;

  MarkingSurface.Tool = Tool;

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface = MarkingSurface;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MarkingSurface;
  }

}).call(this);
