// Generated by CoffeeScript 1.4.0
(function() {
  var BACKSPACE, BaseClass, CASED_ATTRIBUTES, DELETE, Mark, MarkingSurface, SVG, SVG_NS, TAB, Tool, ToolControls, addEvent, elementAndParents, events, matchesSelector, removeEvent,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (!('classList' in document.body)) {
    throw new Error('MarkingSurface requires `classList` or a polyfill');
  }

  BACKSPACE = 8;

  DELETE = 46;

  TAB = 9;

  events = {};

  elementAndParents = function(element) {
    var currentElement, elements;
    elements = [];
    currentElement = element;
    while (currentElement != null) {
      elements.push(currentElement);
      currentElement = currentElement.parentNode;
    }
    return elements;
  };

  matchesSelector = function(element, selector, root) {
    if (root == null) {
      root = document;
    }
    return __indexOf.call(root.querySelectorAll(selector), element) >= 0;
  };

  addEvent = function() {
    var delegatedHandler, element, eventName, handler, selector, _arg, _i, _ref;
    element = arguments[0], _arg = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), eventName = arguments[_i++], handler = arguments[_i++];
    selector = _arg[0];
    delegatedHandler = function(e) {
      var matched, _j, _len, _ref;
      if (selector != null) {
        matched = false;
        _ref = elementAndParents(e.target);
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          element = _ref[_j];
          if (matchesSelector(element, selector)) {
            matched = true;
          }
        }
      }
      if ((!(selector != null)) || matched) {
        return handler.call(element, e);
      }
    };
    if ((_ref = events[eventName]) == null) {
      events[eventName] = [];
    }
    events[eventName].push({
      element: element,
      selector: selector,
      handler: handler,
      delegatedHandler: delegatedHandler
    });
    element.addEventListener(eventName, delegatedHandler, false);
    return null;
  };

  removeEvent = function() {
    var element, eventName, handler, i, selector, set, _arg, _i, _j, _len, _ref;
    element = arguments[0], _arg = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), eventName = arguments[_i++], handler = arguments[_i++];
    selector = _arg[0];
    _ref = events[eventName];
    for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
      set = _ref[i];
      if (element === set.element && selector === set.selector && handler === set.handler) {
        element.removeEventListener(eventName, set.delegatedHandler, false);
        events[eventName].splice(i, 1);
        return;
      }
    }
    return null;
  };

  BaseClass = (function() {

    BaseClass.prototype.events = null;

    function BaseClass(params) {
      var property, value;
      if (params == null) {
        params = {};
      }
      for (property in params) {
        if (!__hasProp.call(params, property)) continue;
        value = params[property];
        if (property in this) {
          this[property] = value;
        }
      }
      this.events = {};
    }

    BaseClass.prototype.on = function(eventName, handler) {
      var _base, _ref;
      if ((_ref = (_base = this.events)[eventName]) == null) {
        _base[eventName] = [];
      }
      this.events[eventName].push(handler);
      return null;
    };

    BaseClass.prototype.trigger = function(eventName, args) {
      var handler, _i, _len, _ref;
      _ref = this.events[eventName] || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        handler.apply(this, args || []);
      }
      return null;
    };

    BaseClass.prototype.off = function(eventName, handler) {
      var h, i, property, _i, _len, _ref;
      if ((eventName != null) && (handler != null)) {
        _ref = this.events[eventName];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          h = _ref[i];
          if (!(h === handler)) {
            continue;
          }
          (this.events[eventName] || []).splice(i, 1);
          return;
        }
      } else if (eventName != null) {
        (this.events[eventName] || []).splice(0);
      } else {
        for (property in this.events) {
          delete this.events[property];
        }
      }
      return null;
    };

    BaseClass.prototype.destroy = function() {
      this.trigger('destroy');
      this.off();
      return null;
    };

    return BaseClass;

  })();

  SVG_NS = 'http://www.w3.org/2000/svg';

  CASED_ATTRIBUTES = ['viewBox'];

  SVG = (function() {

    SVG.prototype.el = null;

    function SVG(tagName, attributes) {
      var className, classes, _i, _len, _ref, _ref1;
      if (typeof tagName !== 'string') {
        _ref = ['svg', tagName], tagName = _ref[0], attributes = _ref[1];
      }
      _ref1 = tagName.split('.'), tagName = _ref1[0], classes = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
      this.el = document.createElementNS(SVG_NS, tagName);
      for (_i = 0, _len = classes.length; _i < _len; _i++) {
        className = classes[_i];
        this.el.classList.add(className);
      }
      this.attr(attributes);
    }

    SVG.prototype.attr = function(attribute, value) {
      var attributes;
      if (typeof attribute === 'string') {
        if (__indexOf.call(CASED_ATTRIBUTES, attribute) < 0) {
          attribute = (attribute.replace(/([A-Z])/g, '-$1')).toLowerCase();
        }
        this.el.setAttributeNS(null, attribute, value);
      } else {
        attributes = attribute;
        for (attribute in attributes) {
          value = attributes[attribute];
          this.attr(attribute, value);
        }
      }
      return null;
    };

    SVG.prototype.addShape = function(tagName, attributes) {
      var shape;
      shape = new this.constructor(tagName, attributes);
      this.el.appendChild(shape.el);
      return shape;
    };

    SVG.prototype.toFront = function() {
      this.el.parentNode.appendChild(this.el);
      return null;
    };

    SVG.prototype.remove = function() {
      this.el.parentNode.removeChild(this.el);
      return null;
    };

    return SVG;

  })();

  Mark = (function(_super) {

    __extends(Mark, _super);

    function Mark() {
      return Mark.__super__.constructor.apply(this, arguments);
    }

    Mark.prototype.set = function(property, value) {
      var map, setter;
      if (typeof property === 'string') {
        setter = this["set " + property];
        this[property] = setter != null ? setter.call(this, value) : value;
        this.trigger('change', [property, value]);
      } else {
        map = property;
        for (property in map) {
          value = map[property];
          this.set(property, value);
        }
      }
      return null;
    };

    Mark.prototype.get = function() {
      var getter, properties, property, values;
      properties = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      values = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          property = properties[_i];
          getter = this["get " + property];
          if (getter != null) {
            _results.push(getter.call(this));
          } else {
            _results.push(this[property]);
          }
        }
        return _results;
      }).call(this);
      if (properties.length === 1) {
        return values[0];
      } else {
        return values;
      }
    };

    Mark.prototype.toJSON = function() {
      var getter, property, result, value;
      result = {};
      for (property in this) {
        value = this[property];
        if (property === 'jQueryEventProxy') {
          continue;
        }
        if (typeof value === 'function') {
          continue;
        }
        if ((property.charAt(0)) === '_') {
          continue;
        }
        getter = this["get " + property];
        result[property] = this.get(property);
      }
      return result;
    };

    return Mark;

  })(BaseClass);

  ToolControls = (function(_super) {

    __extends(ToolControls, _super);

    ToolControls.prototype.tool = null;

    ToolControls.prototype.el = null;

    ToolControls.prototype.className = 'marking-tool-controls';

    ToolControls.prototype.label = null;

    ToolControls.prototype.deleteButton = null;

    ToolControls.prototype.template = '<span class="tool-label"></span>\n<button name="delete-mark">&times;</button>';

    function ToolControls() {
      this.render = __bind(this.render, this);

      this.onToolDestroy = __bind(this.onToolDestroy, this);

      this.onToolDeselect = __bind(this.onToolDeselect, this);

      this.onToolSelect = __bind(this.onToolSelect, this);

      this.onClickDelete = __bind(this.onClickDelete, this);

      this.onMouseDown = __bind(this.onMouseDown, this);

      var _this = this;
      ToolControls.__super__.constructor.apply(this, arguments);
      this.el = document.createElement('div');
      this.el.classList.add(this.className);
      this.el.classList.add(this.constructor.prototype.className);
      this.el.innerHTML = (typeof this.template === "function" ? this.template(this) : void 0) || this.template;
      this.label = this.el.querySelector('.tool-label');
      this.deleteButton = this.el.querySelector('button[name="delete-mark"]');
      addEvent(this.el, 'mousedown', this.onMouseDown);
      if (this.deleteButton != null) {
        addEvent(this.deleteButton, 'click', this.onClickDelete);
      }
      this.tool.on('select', this.onToolSelect);
      this.tool.on('initial-release', function() {
        if (_this.tool.isComplete()) {
          return _this.el.classList.add('complete');
        }
      });
      this.tool.mark.on('change', this.render);
      this.tool.on('deselect', this.onToolDeselect);
      this.tool.on('destroy', this.onToolDestroy);
    }

    ToolControls.prototype.moveTo = function(x, y) {
      var bottom, height, hidden, left, panX, panY, right, top, width, zoomBy, _ref, _ref1, _ref2;
      _ref = this.tool.surface, zoomBy = _ref.zoomBy, panX = _ref.panX, panY = _ref.panY, width = _ref.width, height = _ref.height;
      this.el.style.position = 'absolute';
      _ref1 = x < width / 2 ? (this.el.classList.remove('to-the-left'), [(x * zoomBy) - (panX * zoomBy), null]) : (this.el.classList.add('to-the-left'), [null, width - ((x * zoomBy) - (panX * zoomBy))]), left = _ref1[0], right = _ref1[1];
      _ref2 = y < height / 2 ? (this.el.classList.remove('from-the-bottom'), [(y * zoomBy) - (panY * zoomBy), null]) : (this.el.classList.add('from-the-bottom'), [null, height - ((y * zoomBy) - (panY * zoomBy))]), top = _ref2[0], bottom = _ref2[1];
      hidden = left < 0 || right < 0 || top < 0 || bottom < 0;
      this.el.style.left = left != null ? "" + left + "px" : '';
      this.el.style.right = right != null ? "" + right + "px" : '';
      this.el.style.top = top != null ? "" + top + "px" : '';
      this.el.style.bottom = bottom != null ? "" + bottom + "px" : '';
      this.el.style.display = hidden ? 'none' : '';
      return null;
    };

    ToolControls.prototype.onMouseDown = function() {
      if (this.tool.surface.disabled) {
        return;
      }
      this.tool.select();
      return null;
    };

    ToolControls.prototype.onClickDelete = function(e) {
      if (this.tool.surface.disabled) {
        return;
      }
      e.preventDefault();
      this.tool.mark.destroy();
      return null;
    };

    ToolControls.prototype.onToolSelect = function() {
      this.el.classList.add('selected');
      return null;
    };

    ToolControls.prototype.onToolDeselect = function() {
      this.el.classList.remove('selected');
      return null;
    };

    ToolControls.prototype.onToolDestroy = function() {
      this.destroy();
      return null;
    };

    ToolControls.prototype.destroy = function() {
      ToolControls.__super__.destroy.apply(this, arguments);
      removeEvent(this.el, 'mousedown', this.onMouseDown);
      removeEvent(this.deleteButton, 'click', this.onClickDelete);
      this.el.parentNode.removeChild(this.el);
      return null;
    };

    ToolControls.prototype.render = function() {
      var _ref;
      if ('_label' in this.tool.mark) {
        if ((_ref = this.label) != null) {
          _ref.innerHTML = this.tool.mark._label;
        }
      }
      return null;
    };

    return ToolControls;

  })(BaseClass);

  events = ['mousedown', 'mouseover', 'mousmove', 'mouseout', 'mouseup', 'touchstart', 'touchmove', 'touchend'];

  Tool = (function(_super) {

    __extends(Tool, _super);

    Tool.Mark = Mark;

    Tool.Controls = ToolControls;

    Tool.prototype.markDefaults = null;

    Tool.prototype.cursors = null;

    Tool.prototype.mark = null;

    Tool.prototype.controls = null;

    Tool.prototype.group = null;

    Tool.prototype.surface = null;

    Tool.prototype.drags = 0;

    function Tool() {
      this.destroy = __bind(this.destroy, this);

      this.onMarkDestory = __bind(this.onMarkDestory, this);

      this.onMarkChange = __bind(this.onMarkChange, this);

      this.handleEvents = __bind(this.handleEvents, this);

      var eventName, _i, _len, _ref;
      Tool.__super__.constructor.apply(this, arguments);
      if ((_ref = this.mark) == null) {
        this.mark = new this.constructor.Mark;
      }
      this.mark.on('change', this.onMarkChange);
      this.mark.on('destroy', this.onMarkDestory);
      this.controls = new this.constructor.Controls({
        tool: this
      });
      this.surface.container.appendChild(this.controls.el);
      this.group = this.surface.svg.addShape('g.tool');
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        eventName = events[_i];
        addEvent(this.group.el, eventName, this.handleEvents);
      }
      this.initialize.apply(this, arguments);
      if (this.markDefaults != null) {
        this.mark.set(this.markDefaults);
      }
    }

    Tool.prototype.addShape = function() {
      var _ref;
      return (_ref = this.group).addShape.apply(_ref, arguments);
    };

    Tool.prototype.onInitialClick = function(e) {
      this.trigger('initial-click', [e]);
      return this.onFirstClick(e);
    };

    Tool.prototype.onInitialDrag = function(e) {
      this.trigger('initial-drag', [e]);
      return this.onFirstDrag(e);
    };

    Tool.prototype.onInitialRelease = function(e) {
      this.drags += 1;
      this.trigger('initial-release', [e]);
      return this.onFirstRelease(e);
    };

    Tool.prototype.handleEvents = function(e) {
      var dragEvent, endEvent, eventName, name, onEnd, onNamedEnd, property, target, value, _ref, _ref1, _ref2,
        _this = this;
      console.log('Handling tool event', e.type, e.target);
      if (this.surface.disabled) {
        return;
      }
      eventName = e.type;
      ({
        name: '*'
      });
      target = e.target || e.srcElement;
      for (property in this) {
        value = this[property];
        if ((value != null ? value.el : void 0) === target) {
          name = property;
          target = value;
        }
      }
      if ((_ref = this["on " + eventName]) != null) {
        _ref.call(this, e);
      }
      if ((_ref1 = this["on " + eventName + " " + name]) != null) {
        _ref1.call(this, e, target);
      }
      switch (eventName) {
        case 'mouseover':
          return this.surface.container.style.cursor = (_ref2 = this.cursors) != null ? _ref2[name] : void 0;
        case 'mouseout':
          return this.surface.container.style.cursor = '';
        case 'mousedown':
        case 'touchstart':
          e.preventDefault();
          this.select();
          dragEvent = eventName === 'mousedown' ? 'mousemove' : 'touchmove';
          endEvent = eventName === 'mousedown' ? 'mouseup' : 'touchend';
          if ('on drag' in this) {
            addEvent(document, dragEvent, this['on drag']);
            onEnd = function() {
              removeEvent(document, dragEvent, _this['on drag']);
              return removeEvent(document, endEvent, onEnd);
            };
            addEvent(document, endEvent, onEnd);
          }
          if (("on drag " + name) in this) {
            addEvent(document, dragEvent, this["on drag " + name]);
            onNamedEnd = function() {
              removeEvent(document, dragEvent, _this["on drag " + name]);
              return removeEvent(document, endEvent, onNamedEnd);
            };
            return addEvent(document, endEvent, onNamedEnd);
          }
      }
    };

    Tool.prototype.onMarkChange = function() {
      this.render.apply(this, arguments);
      return null;
    };

    Tool.prototype.onMarkDestory = function() {
      this.destroy.apply(this, arguments);
      return null;
    };

    Tool.prototype.select = function() {
      this.group.attr({
        opacity: 1
      });
      this.group.toFront();
      this.trigger('select', arguments);
      return null;
    };

    Tool.prototype.deselect = function() {
      this.group.attr({
        opacity: 0.5
      });
      this.trigger('deselect', arguments);
      return null;
    };

    Tool.prototype.destroy = function() {
      var eventName, _i, _len;
      Tool.__super__.destroy.apply(this, arguments);
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        eventName = events[_i];
        removeEvent(this.group.el, eventName, this.handleEvents);
      }
      this.group.remove();
      this.trigger('destroy', arguments);
      return null;
    };

    Tool.prototype.pointerOffset = function() {
      var _ref;
      return (_ref = this.surface).pointerOffset.apply(_ref, arguments);
    };

    Tool.prototype.initialize = function() {};

    Tool.prototype.onFirstClick = function(e) {};

    Tool.prototype.onFirstDrag = function(e) {};

    Tool.prototype.isComplete = function() {
      return this.drags === 1;
    };

    Tool.prototype.onFirstRelease = function(e) {};

    Tool.prototype.render = function() {};

    return Tool;

  })(BaseClass);

  MarkingSurface = (function(_super) {
    var zoomSnapTolerance;

    __extends(MarkingSurface, _super);

    MarkingSurface.prototype.tool = Tool;

    MarkingSurface.prototype.container = null;

    MarkingSurface.prototype.className = 'marking-surface';

    MarkingSurface.prototype.tabIndex = 0;

    MarkingSurface.prototype.svg = null;

    MarkingSurface.prototype.width = NaN;

    MarkingSurface.prototype.height = NaN;

    MarkingSurface.prototype.zoomBy = 1;

    zoomSnapTolerance = 0.05;

    MarkingSurface.prototype.panX = 0;

    MarkingSurface.prototype.panY = 0;

    MarkingSurface.prototype.tools = null;

    MarkingSurface.prototype.selection = null;

    MarkingSurface.prototype.marks = null;

    MarkingSurface.prototype.disabled = false;

    function MarkingSurface(params) {
      var _ref, _ref1, _ref2, _ref3;
      if (params == null) {
        params = {};
      }
      this.onRelease = __bind(this.onRelease, this);

      this.onDrag = __bind(this.onDrag, this);

      this.onMouseDown = __bind(this.onMouseDown, this);

      this.onMouseMove = __bind(this.onMouseMove, this);

      MarkingSurface.__super__.constructor.apply(this, arguments);
      if ((_ref = this.container) == null) {
        this.container = document.createElement('div');
      }
      this.container.classList.add(this.constructor.prototype.className);
      this.container.classList.add(this.className);
      this.container.setAttribute('tabindex', this.tabIndex);
      this.container.setAttribute('unselectable', true);
      addEvent(this.container, 'mousedown', this.onMouseDown);
      addEvent(this.container, 'mousemove', this.onMouseMove);
      addEvent(this.container, 'touchstart', this.onTouchStart);
      addEvent(this.container, 'touchmove', this.onTouchMove);
      if (this.container.parentNode != null) {
        this.width || (this.width = this.container.clientWidth);
        this.height || (this.height = this.container.clientHeight);
      }
      if ((_ref1 = this.svg) == null) {
        this.svg = new SVG({
          width: this.width,
          height: this.height
        });
      }
      this.svg.el.style.display = 'block';
      this.container.appendChild(this.svg.el);
      if ((_ref2 = this.marks) == null) {
        this.marks = [];
      }
      if ((_ref3 = this.tools) == null) {
        this.tools = [];
      }
      if (this.disabled) {
        disable();
      }
    }

    MarkingSurface.prototype.resize = function(width, height) {
      this.width = width != null ? width : this.width;
      this.height = height != null ? height : this.height;
      this.svg.attr({
        width: this.width,
        height: this.height
      });
      return null;
    };

    MarkingSurface.prototype.zoom = function(zoomBy) {
      var _ref;
      this.zoomBy = zoomBy != null ? zoomBy : 1;
      if ((1 - this.zoomSnapTolerance < (_ref = this.zoomBy) && _ref < 1 + this.zoomSnapTolerance)) {
        this.zoomBy = 1;
      }
      this.pan();
      return null;
    };

    MarkingSurface.prototype.pan = function(panX, panY) {
      var tool, _i, _len, _ref;
      this.panX = panX != null ? panX : this.panX;
      this.panY = panY != null ? panY : this.panY;
      this.panX = Math.min(this.panX, this.width, this.width - (this.width / this.zoomBy));
      this.panY = Math.min(this.panY, this.height, this.height - (this.height / this.zoomBy));
      this.svg.attr('viewBox', "" + this.panX + " " + this.panY + " " + (this.width / this.zoomBy) + " " + (this.height / this.zoomBy));
      _ref = this.tools;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tool = _ref[_i];
        tool.render();
      }
      return null;
    };

    MarkingSurface.prototype.onMouseMove = function(e) {
      var x, y, _ref;
      if (this.zoomBy === 1) {
        return;
      }
      _ref = this.pointerOffset(e), x = _ref.x, y = _ref.y;
      this.panX = (this.width - (this.width / this.zoomBy)) * (x / this.width);
      this.panY = (this.height - (this.height / this.zoomBy)) * (y / this.height);
      this.pan();
      return null;
    };

    MarkingSurface.prototype.onMouseDown = function(e) {
      var dragEvent, element, mark, releaseEvent, tool, _i, _len, _ref, _ref1,
        _this = this;
      if (this.disabled) {
        return;
      }
      if (e.defaultPrevented) {
        return;
      }
      _ref = elementAndParents(e.target);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        if ((_ref1 = element.classList) != null ? _ref1.contains(this.tool.Controls.prototype.className) : void 0) {
          return;
        }
      }
      e.preventDefault();
      if (!(this.selection != null) || this.selection.isComplete()) {
        if (this.tool != null) {
          tool = new this.tool({
            surface: this
          });
          mark = tool.mark;
          this.tools.push(tool);
          this.marks.push(mark);
          tool.on('select', function() {
            var i, index, t, _j, _len1, _ref2, _ref3;
            if (_this.selection === tool) {
              return;
            }
            if ((_ref2 = _this.selection) != null) {
              _ref2.deselect();
            }
            _ref3 = _this.tools;
            for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
              t = _ref3[i];
              if (t === tool) {
                index = i;
              }
            }
            _this.tools.splice(index, 1);
            _this.tools.push(tool);
            return _this.selection = tool;
          });
          tool.on('deselect', function() {
            return _this.selection = null;
          });
          tool.on('destroy', function() {
            var i, index, t, _j, _len1, _ref2, _ref3;
            _ref2 = _this.tools;
            for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
              t = _ref2[i];
              if (t === tool) {
                index = i;
              }
            }
            _this.tools.splice(index, 1);
            if (tool === _this.selection) {
              return (_ref3 = _this.tools[_this.tools.length - 1]) != null ? _ref3.select() : void 0;
            }
          });
          mark.on('destroy', function() {
            var i, index, m, _j, _len1, _ref2;
            _ref2 = _this.marks;
            for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
              m = _ref2[i];
              if (m === mark) {
                index = i;
              }
            }
            _this.marks.splice(index, 1);
            return _this.trigger('destroy-mark', [mark]);
          });
          tool.select();
          this.trigger('create-mark', [mark, tool]);
        }
      } else {
        tool = this.selection;
      }
      if (tool != null) {
        tool.select();
        tool.onInitialClick(e);
      }
      dragEvent = e.type === 'mousedown' ? 'mousemove' : 'touchmove';
      releaseEvent = e.type === 'mousedown' ? 'mouseup' : 'touchend';
      addEvent(document, dragEvent, this.onDrag);
      addEvent(document, releaseEvent, this.onRelease);
      return null;
    };

    MarkingSurface.prototype.onDrag = function(e) {
      var _ref;
      e.preventDefault();
      if ((_ref = this.selection) != null) {
        _ref.onInitialDrag.apply(_ref, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.onRelease = function(e) {
      var dragEvent, _ref;
      e.preventDefault();
      dragEvent = e.type === 'mouseup' ? 'mousemove' : 'touchmove';
      removeEvent(document, dragEvent, this.onDrag);
      removeEvent(document, e.type, this.onRelease);
      if ((_ref = this.selection) != null) {
        _ref.onInitialRelease.apply(_ref, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.disable = function(e) {
      var _ref;
      if (this.disabled) {
        return;
      }
      this.disabled = true;
      this.container.setAttribute('disabled', 'disabled');
      this.container.classList.add('disabled');
      if ((_ref = this.selection) != null) {
        _ref.deselect();
      }
      return null;
    };

    MarkingSurface.prototype.enable = function(e) {
      if (!this.disabled) {
        return;
      }
      this.disabled = false;
      this.container.removeAttribute('disabled');
      this.container.classList.remove('disabled');
      return null;
    };

    MarkingSurface.prototype.destroy = function() {
      var mark, _i, _len, _ref;
      _ref = this.marks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mark = _ref[_i];
        mark.destroy();
      }
      removeEvent(this.container, 'mousedown', this.onMouseDown, false);
      removeEvent(this.container, 'mousemove', this.onMouseMove, false);
      removeEvent(this.container, 'touchstart', this.onTouchStart, false);
      removeEvent(this.container, 'touchmove', this.onTouchMove, false);
      return null;
    };

    MarkingSurface.prototype.pointerOffset = function(e) {
      var element, elements, left, originalEvent, top, x, y, _i, _len;
      if ('originalEvent' in e) {
        originalEvent = e.originalEvent;
      }
      if ((originalEvent != null) && 'touches' in originalEvent) {
        e = originalEvent.touches[0];
      }
      elements = elementAndParents(this.container);
      left = 0;
      top = 0;
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        element = elements[_i];
        if (!isNaN(element.offsetLeft)) {
          left += element.offsetLeft;
        }
        if (!isNaN(element.offsetTop)) {
          top += element.offsetTop;
        }
      }
      x = e.pageX - left;
      y = e.pageY - top;
      return {
        x: x,
        y: y
      };
    };

    return MarkingSurface;

  })(BaseClass);

  MarkingSurface.Mark = Mark;

  MarkingSurface.ToolControls = ToolControls;

  MarkingSurface.Tool = Tool;

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface = MarkingSurface;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MarkingSurface;
  }

}).call(this);
